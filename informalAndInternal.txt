Music

A: Informal language specification
=================================

BeatSequencer allows the specification of musical phrases as lists of MIDI notes which can be:
* Assigned to variables and dereferenced
* Repeated
* Concatenated to one another
* Modulated
* Played one at a time
* Played concurrently with other phrases

S.1 Programs
------------


S.2 Arithmetic and expressions
------------------------------
BeatSequencer allows standard integer arithmetic. The operations supported are addition, subtraction, multiplication, division and exponentiation.

Non-keyword alphanumeric identifiers denote variables that may have integers bound to them.


S.3 Predicates
--------------
BeatSequencer allows comparison of integers using relational operators that return a boolean result:
x > y       x greater than y
x < y       x less than y
x >= y      x greater than or equal to y
x <= y      x less than or equal to y
x != y      x not equal to y
x == y      x equal to y


S.4 Selection statements
------------------------

BeatSequencer provides two selection statements:

if _pred then _statement else _statement
if _pred then _statement

where _pred is a predicate as defined in section S.3, and _statement is any statement.


S.5 Iteration statements
------------------------
BeatSequencer provides one iteration statement:

while _pred do _statement

where _pred is a predicate as defined in section S.3, and _statement is any statement.


S.6 Domain specific types
-------------------------
BeatSequencer has the following domain specific types:

Phrase - a comma-delimited list of notes to be played in order written inside square brackets, 
         assignable to an identifier. Phrases can be appended or repeated with '+' or '*' operators.
    E.g:
        twoBarKickLoop = [C:4:4, C4:4:4, C4:4:4, C4:4:4] * 2
        oneBarRest = [.:.:16] * 16
        cMajorScale = [C:4:8, D:4:8, E:4:8, F:4:8, G:4:8, A:4:8, B:4:8, C:4:8]

Pattern - a list of phrases to be played at the same time
    E.g:
        bassline_intro;
        bassline_intro[0] = kick_loop * 2 + kick_snare_loop * 2;
        bassline_intro[1] = bassline;
        4_bar_rest_pattern;
        for (int i = 0; i < length(4_bar_rest_pattern); i++) {
            4_bar_rest_pattern[i] = restBar * 4;
        };

Track - A track has an integer numerical identifier, a user-specifiable name, and the name of the instrument
        the track will play. 
    E.g:
        0: "drums", drums;
        1: "synth1", synth;
        2: "synth2", synth;


S.7 Domain specific operations
------------------------------
BeatSequencer provides concatenation and repetition for notes, phrases, and patterns. In this context, the '+' symbol acts as the concatenation operator
and the '*' as the repetition operator.

'+' acts as follows:
    phrase1 + phrase2: returns a single new phrase that is the concatenation of phrase1 and phrase2, e.g. [C:4:8, D5==] + [E4, {C,E,G}=] returns [C4, D5==, E4, {C,E,G}=]
    pattern1 + pattern2: returns a new pattern where for each index i, phrases pattern1[i] and pattern2[i] are concatenated, e.g. phattern3[i] = pattern1[i] (a phrase) concatenated with pattern2[i] (another phrase)
    
'*' acts as follows:
    note1 * k: returns a new phrase consisting of k instances of note1, e.g. C4 * 4 returns [C4, C4, C4, C4]
    phrase1 * k: returns a new phrase consisting of k instances of phrase1 concatenated, e.g. [C4, D5==] * 2 = [C4, D5==, C4, D5==]
    pattern1 * k: returns a new pattern where for each index i, the phrase pattern1[i] is repeated as per repetition for phrases

Signatures for the operations above (also found in section B):
    concat(_a:Note, _b:Note):Note
    concat(_a:Phrase, _b:Phrase):Phrase
    concat(_a:Pattern, _b:Pattern):Pattern
    
    repeat(_a:Note, _x:__int32):Phrase
    repeat(_a:Phrase, _x:__int32):Phrase
    repeat(_a:Pattern, _x:__int32):Pattern


BeatSequencer also provides one DSL-type statement

    backend(_v1:int, _v2:int, _v3:int):int

where v1, v2 and v3 are integer expressions. 

This statement then activates the corresponding method in class ValueUserPlugin via the __user() function in the ART value system.

The behaviour depends on the code implemented in that class (TODO).


B: Internal syntax constructors and arities
===========================================

Constructors for domain-specific types
--------------------------------------
InstrumentTrack(_channel_id:__int32, _trackName:__string, _instrument:__string):InstrumentTrack
Create a new instrument track with id _channel_id, human-readable name _trackName, playing instrument _instrument.

Note(_pitch:__string, _length:__int32):Note
Create a new note which should play pitch _pitch for the equivalenth of _length semiquavers,
e.g. note("Ab", 4) represents an Ab with crotchet length.

Phrase(_notes:__list, _length:__int32):Phrase
A phrase is an constructed from an ordered list of notes. Evaluate _length to be the sum of the lengths of notes in the list.

Pattern(__channels:__int32, __phrases:__array):Pattern
A pattern consists of an array of phrases, with each array index corresponding to the numerical ID
of an instrument track (the corresponding track will play the phrase). The interpreter will enforce
that all phrases belonging to a pattern are the same length, otherwise the pattern is illegal.


Basic primitives
----------------
int(_int:__int32)
A basic integer type

String(_string:__string)
Basic String type


Operations, syntax, arities
---------------------------
assign(_name: String, _a:Object)
Assign variable _a to name _name in the store. Works over all basic primitives and domain-specific types.

add(_E1:__int32, _E2:__int32):__int32 integer addition: E_1 + E_2

sub(_E1:__int32, _E2:__int32):__int32 integer subtraction: E_1 - E_2

mult(_E1:__int32, _E2:__int32):__int32 integer addition: E_1 * E_2

div(_E1:__int32, E2:__inte3):__int32 integer floor division: E1 /E2

gt(_E1:__int32, _E2:__int32):__boolean integer greater-than E_1 > E_2

ge(_E1:__int32, _E2:__int32):__boolean integer greater-than or equal E_1 >= E_2

lt(_E1:__int32, _E2:__int32):__boolean integer lesser-than E_1 < E_2

le(_E1:__int32, _E2:__int32):__boolean integer lesser-than or equal E_1 <= E_2

ne(_E1:__int32, _E2:__int32):__boolean integer not-equals E_1 ne E_2

eq(_E1:__int32, _E2:__int32):__bolean integer equality E1 equals E2

deref(_N)) retrieve binding for name _N in variables map

concat(_a:Note, _b:Note):Note
Return a new phrase that is the concatenation of two notes _a and _b.

concat(_a:Phrase, _b:Phrase):Phrase
Return a new phrase that is the concatenation of phrase _a and _b_.

concat(_a:Pattern, _b:Pattern):Pattern
Return a new Pattern consisting of the phrases in each channel of pattern _a concatenated with their corresponding phrases in pattern _b.concat(_a:Note, _b:Note):Note

repeat(_a:Note, _x:__int32):Phrase
Construct a new phrase by concatenating _x instances of _a together.
 
repeat(_a:Phrase, _x:__int32):Phrase
Construct a new phrase from phrase _a by concatenating _x instances of _a together.

repeat(_a:Pattern, _x:__int32):Pattern
Construct a new pattern from pattern _a by concatenating _x instances of _a together.

increment(_note: Note, _step:__int32):Note
Returns a new Note with the pitch incremented by _step semitones (or decremented if given a negative number).
Note, this creates and returns a new Note instance rather than changing the pitch of the provided _note instance.

length(_phrase:Phrase):__int32
Return the length (in semiquavers) of the given phrase, i.e. the sum of all notes in this phrase.

length(_note:Note):__int32
Return the length (in semiquavers) of the given note.

length(_pattern:Pattern):__int32
Return the length (in semiquavers) of the given pattern. The interpreter should enforce that each phrase in the
pattern is indeed the same length, otherwise the pattern is illegal (and this operation is undefined).

play(_pattern:Pattern)
Call the Java MIDI system to play the tracks in the given pattern.

seq(_S1, _S2)
Execute _S1, followed by _S2.

if(_P:__bool, _S1, _S2)
Selection, if _P evaluates to true then execute _S1, else execute _S2

while(_P:__bool, _C1, _C2)
Iteration, while _P is true execute _S1, else execute _S2
