Music

A: Informal language specification
=================================

BeatSequencer allows the specification of musical phrases as lists of MIDI notes which can be:
* Assigned to variables and dereferenced
* Repeated
* Concatenated to one another
* Modulated
* Played one at a time
* Played concurrently with other phrases

S.1 Programs
------------
A BeatSequencer program is one or more statements

Statements are separated by the ; and-also operator. There is no statement terminator.

A sequence of whitespace characters can be used wherever one whitespace is valid.

S.2 Arithmetic and expressions
------------------------------
BeatSequencer allows standard integer arithmetic. The operations supported are addition, subtraction, multiplication, division and exponentiation.

Non-keyword alphanumeric identifiers denote variables that may have integers or strings (musical phrases) bound to them.

Variables can be derefenced to obtain their integer or string value stored in the symbol table.

S.3 Predicates
--------------
BeatSequencer allows comparison of integers using relational operators that return a boolean result:
x > y       x greater than y
x < y       x less than y
x >= y      x greater than or equal to y
x <= y      x less than or equal to y
x != y      x not equal to y
x == y      x equal to y


S.4 Selection statements
------------------------

BeatSequencer provides two selection statements:

if _pred then _statement else _statement
if _pred then _statement

where _pred is a predicate as defined in section S.3, and _statement is any statement.


S.5 Iteration statements
------------------------
BeatSequencer provides one iteration statement:

while _pred do _statement

where _pred is a predicate as defined in section S.3, and _statement is any statement.


S.6 Domain specific types
-------------------------
BeatSequencer has the following domain specific types:

Phrase - a comma-delimited list of MIDI notes to be played in order written inside square brackets, 
         assignable to an identifier. Phrases can be appended or repeated with '+' or '*' operators.
    E.g:
        twoBarKickLoop = [C4:4, C4:4, C4:4, C4:4] * 2
        oneBarRest = [.:16] * 16
        cMajorScale = [C4:8, D4:8, E4:8, F4:8, G4:8, A4:8, B4:8, C4:8, {C4/E4/G4}:4]

  Phrases are represented by strings and can be stored in the symbol table with the assignment operator '='. The processing 
  and musical handling of phrase strings is handled by the backend.

  A note in a phrase consists of a MIDI note name, a colon, and then an integer representing its subdivision. For example,
  "C4:4" represents a crotchet (quarter note) middle C. "G5:8" represents a quaver (eighth note) G in the octave above middle C.
  
  Chords can be written with the following syntax: "{C4/E4/G4}:4", where inside the curly braces is a list of MIDI notes separated by a slash, and the
  colon and integer after the closing brace represents the subdivision of the entire chord.

  Rests are written with a single dot, followed by a colon and the subdivision.

  A phrase can be played on one channel with the `play(channel, phrase)` domain-specific operation, or multiple phrases can be played across
  multiple channels with the `playConcurrent(concChannel(channel, phrase, concChannel(channel, phrase)))` domain-specific operation. This operation
  can be nested as many times as you like with the pattern `concChannel(channel, phrase, concChannel(...))`.
    
Channel - a channel consists of a mapping from an integer key to an integer representing a MIDI instrument. The full list of MIDI instruments
          supported by BeatSequencer (from the Java MIDI subsystem) can be viewed in `documentation/instrmuentlist.txt`.

  Channels have no constructor. They do not need to be explicitly constructed as they already exist in the backend, but can be mapped to an instrument 
  with the `setChannelInstrument` domain-specific operation. If no instrument is provided to a channel, any patterns played
  on the channel will be played with the default instrument 0 (Acoustic Grand Piano). 

S.7 Domain specific operations
------------------------------
BeatSequencer provides concatenation, repetition and modulation for phrases. In this context, the '+' symbol acts as the concatenation operator, '*' as the 
repetition operator and '^' as the modulation operator.

'+' acts as follows:
    phrase1 + phrase2: returns a single new phrase that is the concatenation of phrase1 and phrase2, 
    e.g. "[C4:8, D5:4]" + "[E4:4, {C2/E2/G2}:8]" returns "[C4:8, D5:4, E4:4, {C2/E2/G2}:8]".
    
'*' acts as follows:
    phrase1 * k: returns a new phrase consisting of k instances of phrase1 concatenated, e.g. "[C4:4, E4:4, G4:4]" * 2
    returns "[C4:4, E4:4, G4:4, C4:4, E4:4, G4:4]".

'^' acts as follows:
    phrase1 ^ k: returns a new phrase consisting of the notes of phrase1 modulated by k semitones, e.g.
    "[C4:4, E4:4, G4:4]" ^ 5 returns "[F4:4, A4:4, C5:4]", and "[C4:4, E4:4, G4:4]" ^ -4 returns "[G#3:4, C4:4, D#4:4]".

Signatures for the operations above can be found in section B.

Overall, BeatSequencer provides 9 DSL-type statements which call corresponding methods in the ValueUserPlugin class:
  
  modulate(_phrase:String _n:String):String calls the backend to return a phrase modulated by _n semitones.

  play(_channel:int, _phrase:String) calls the backend to play a phrase on the given channel.

  setBpm(_n:int) sets the tempo all phrases will be played at.

  concat(_phrase1:String, _phrase2:String):String calls the backend to return _phrase1 and _phrase2 concatenated.

  repeat(_phrase:String, _n:int):String calls the backend to return _n instances of a phrase concatenated to each other.

  printAvailableInstruments() calls the backend to print the available instruments and their corresponding numbers of the Java MIDI subsystem.

  setChannelInstrument(_channel:int, _instrument:int) calls the backend to map a particular channel to a particular instrument.

  concChannel(_channel:int, _phrase:String) is used to build up a list of channels and phrases to be played concurrently.

  playConcurrent(_concChannels:List) accepts a nested list of concurrent channels, taking the form 
      of concChannel(_channel:int, _phrase:String, _next:concChannel) or concChannel(_channel:int, _phrase:String) to terminate the nested list.
      When the list is processed, playConcurrent calls the backend to play the given channels/phrases concurrently.


B: Internal syntax constructors and arities
===========================================

Constructors for domain-specific types
--------------------------------------
InstrumentTrack(_channel_id:__int32, _trackName:__string, _instrument:__string):InstrumentTrack
Create a new instrument track with id _channel_id, human-readable name _trackName, playing instrument _instrument.

Note(_pitch:__string, _length:__int32):Note
Create a new note which should play pitch _pitch for the equivalenth of _length semiquavers,
e.g. note("Ab", 4) represents an Ab with crotchet length.

Phrase(_notes:__list, _length:__int32):Phrase
A phrase is an constructed from an ordered list of notes. Evaluate _length to be the sum of the lengths of notes in the list.

Pattern(__channels:__int32, __phrases:__array):Pattern
A pattern consists of an array of phrases, with each array index corresponding to the numerical ID
of an instrument track (the corresponding track will play the phrase). The interpreter will enforce
that all phrases belonging to a pattern are the same length, otherwise the pattern is illegal.


Basic primitives
----------------
int(_int:__int32)
A basic integer type

String(_string:__string)
Basic String type


Operations, syntax, arities
---------------------------
assign(_name: String, _a:Object)
Assign variable _a to name _name in the store. Works over all basic primitives and domain-specific types.

add(_E1:__int32, _E2:__int32):__int32 integer addition: E_1 + E_2

sub(_E1:__int32, _E2:__int32):__int32 integer subtraction: E_1 - E_2

mult(_E1:__int32, _E2:__int32):__int32 integer addition: E_1 * E_2

div(_E1:__int32, E2:__inte3):__int32 integer floor division: E1 /E2

gt(_E1:__int32, _E2:__int32):__boolean integer greater-than E_1 > E_2

ge(_E1:__int32, _E2:__int32):__boolean integer greater-than or equal E_1 >= E_2

lt(_E1:__int32, _E2:__int32):__boolean integer lesser-than E_1 < E_2

le(_E1:__int32, _E2:__int32):__boolean integer lesser-than or equal E_1 <= E_2

ne(_E1:__int32, _E2:__int32):__boolean integer not-equals E_1 ne E_2

eq(_E1:__int32, _E2:__int32):__bolean integer equality E1 equals E2

deref(_N)) retrieve binding for name _N in variables map

concat(_a:Note, _b:Note):Note
Return a new phrase that is the concatenation of two notes _a and _b.

concat(_a:Phrase, _b:Phrase):Phrase
Return a new phrase that is the concatenation of phrase _a and _b_.

concat(_a:Pattern, _b:Pattern):Pattern
Return a new Pattern consisting of the phrases in each channel of pattern _a concatenated with their corresponding phrases in pattern _b.concat(_a:Note, _b:Note):Note

repeat(_a:Note, _x:__int32):Phrase
Construct a new phrase by concatenating _x instances of _a together.
 
repeat(_a:Phrase, _x:__int32):Phrase
Construct a new phrase from phrase _a by concatenating _x instances of _a together.

repeat(_a:Pattern, _x:__int32):Pattern
Construct a new pattern from pattern _a by concatenating _x instances of _a together.

increment(_note: Note, _step:__int32):Note
Returns a new Note with the pitch incremented by _step semitones (or decremented if given a negative number).
Note, this creates and returns a new Note instance rather than changing the pitch of the provided _note instance.

length(_phrase:Phrase):__int32
Return the length (in semiquavers) of the given phrase, i.e. the sum of all notes in this phrase.

length(_note:Note):__int32
Return the length (in semiquavers) of the given note.

length(_pattern:Pattern):__int32
Return the length (in semiquavers) of the given pattern. The interpreter should enforce that each phrase in the
pattern is indeed the same length, otherwise the pattern is illegal (and this operation is undefined).

play(_pattern:Pattern)
Call the Java MIDI system to play the tracks in the given pattern.

seq(_S1, _S2)
Execute _S1, followed by _S2.

if(_P:__bool, _S1, _S2)
Selection, if _P evaluates to true then execute _S1, else execute _S2

while(_P:__bool, _C1, _C2)
Iteration, while _P is true execute _S1, else execute _S2
