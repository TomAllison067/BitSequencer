// == ASSIGNMENT ==


-assignStr
_str |> __string(_)
---
assign(_ID, _str), _sig -> __done, __put(_sig, _ID, _str)

-assignInt
_n |> __int32(_)   
---
assign(_X, _n), _sig -> __done, __put(_sig, _X, _n)

-assignIntResolve
_E, _sig -> _I, _sigP 
---
assign(_X,_E), _sig -> assign(_X, _I), _sigP

-assignStrResolve
_str, _sig -> _strP, _sigP
---
assign(_ID, _str), _sig -> assign(_ID, _strP), _sigP

// Returns __string
-modulate
_phrase |> __string(_) _n |> __int32(_)
---
modulate(_phrase, _n), _sig -> __user(2, _phrase, _n), _sig

-modulateResolveRight
_phrase |> __string(_) _E1, _sig -> _I1, _sigP
---
modulate(_phrase, _E1), _sig -> modulate(_phrase, _I1), _sigP

-modulateResolveLeft
_phrase, _sig -> _phraseP, _sigP
---
modulate(_phrase, _E1), _sig -> modulate(_phraseP, _E1), _sigP

// == SEQUENCING ==
-sequenceDone
---
seq(__done, _C), _sig -> _C, _sig

-sequence 
_C1, _sig -> _C1P, _sigP
---
seq(_C1, _C2), _sig -> seq(_C1P, _C2), _sigP

// == ARITHMETIC ==
-add
_n1 |> __int32(_) _n2 |> __int32(_)
---
add(_n1, _n2), _sig -> __add(_n1, _n2), _sig

-addRight
_n |> __int32(_) _E2, _sig -> _I2, _sigP
---
add(_n, _E2), _sig -> add(_n, _I2), _sigP

-addLeft
_E1, _sig -> _I1, _sigP
---
add(_E1, _E2), _sig -> add(_I1, _E2), _sigP

-sub
_n1 |> __int32(_) _n2 |> __int32(_)
---
sub(_n1, _n2),_sig ->  __sub(_n1, _n2),_sig

-subRight
_n |> __int32(_) _E2,_sig -> _I2,_sigP   
---
sub(_n, _E2),_sig -> sub(_n, _I2), _sigP

-subLeft
_E1,_sig -> _I1,_sigP
---
sub(_E1, _E2),_sig -> sub(_I1, _E2), _sigP

-mul
_n1 |> __int32(_) _n2 |> __int32(_)
---
mul(_n1, _n2), _sig -> __mul(_n1, _n2), _sig

-mulRight
_n |> __int32(_) _E2, _sig -> _I2, _sigP
---
mul(_n, _E2), _sig -> mul(_n, _I2), _sigP

-mulLeft
_E1, _sig -> _I1, _sigP
---
mul(_E1, _E2), _sig -> mul(_I1, _E2), _sigP

-div
_n1 |> __int32(_) _n2 |> __int32(_)
---
div(_n1, _n2), _sig -> __div(_n1, _n2), _sig

-divRight
_n |> __int32(_) _E2, _sig -> _I2, _sigP
---
div(_n, _E2), _sig -> div(_n, _I2), _sigP

-divLeft
_E1, _sig -> _I1, _sigP
---
div(_E1, _E2), _sig -> div(_I1, _E2), _sigP

// == RELATIONAL ==
-gt
_n1 |> __int32(_) _n2 |> __int32(_)
---
gt(_n1, _n2),_sig ->  __gt(_n1, _n2),_sig 

-gtRight
_n |> __int32(_) _E2, _sig -> _I2,_sigP 
---
gt(_n, _E2),_sig -> gt(_n, _I2), _sigP

-gtLeft
_E1, _sig -> _I1, _sigP 
---
gt(_E1, _E2),_sig -> gt(_I1, _E2), _sigP

-ge
_n1 |> __int32(_) _n2 |> __int32(_)
---
ge(_n1, _n2),_sig ->  __ge(_n1, _n2),_sig 

-geRight
_n |> __int32(_) _E2, _sig -> _I2,_sigP 
---
ge(_n, _E2),_sig -> ge(_n, _I2), _sigP

-geLeft
_E1, _sig -> _I1, _sigP 
---
ge(_E1, _E2),_sig -> ge(_I1, _E2), _sigP

-lt
_n1 |> __int32(_) _n2 |> __int32(_)
---
lt(_n1, _n2), _sig -> __lt(_n1, _n2), _sig

-ltRight
_n |> __int32(_) _E2, _sig -> _I2, _sigP
---
lt(_n, _E2), _sig -> lt(_n, _I2), _sigP

-ltLeft
_E1, _sig -> _I1, _sigP
---
lt(_E1, _E2), _sig -> lt(_I1, _E2), _sigP

-le
_n1 |> __int32(_) _n2 |> __int32(_)
---
le(_n1, _n2), _sig -> __le(_n1, _n2), _sig

-leRight
_n |> __int32(_) _E2, _sig -> _I2, _sigP
---
le(_n, _E2), _sig -> le(_n, _I2), _sigP

-leLeft
_E1, _sig -> _I1, _sigP
---
le(_E1, _E2), _sig -> le(_I1, _E2), _sigP

-ne
_n1 |> __int32(_) _n2 |> __int32(_)
---
ne(_n1, _n2),_sig ->  __ne(_n1, _n2),_sig

-neRight
_n |> __int32(_)  _E2, _sig -> _I2,_sigP 
---
ne(_n, _E2),_sig -> ne(_n, _I2), _sigP

-neLeft
_E1, _sig -> _I1, _sigP 
---
ne(_E1, _E2),_sig -> ne(_I1, _E2), _sigP

-eq
_n1 |> __int32(_) _n2 |> __int32(_)
---
eq(_n1, _n2),_sig ->  __eq(_n1, _n2),_sig

-eqRight
_n |> __int32(_)  _E2, _sig -> _I2,_sigP 
---
eq(_n, _E2),_sig -> eq(_n, _I2), _sigP

-eqLeft
_E1, _sig -> _I1, _sigP 
---
eq(_E1, _E2),_sig -> eq(_I1, _E2), _sigP

// == CONTROL FLOW ==
-ifTrue 
---
if(True, _C1, _C2),_sig -> _C1, _sig

-ifFalse 
---
if(False, _C1, _C2),_sig -> _C2,_sig

-ifResolve
_E, _sig -> _EP, _sigP
---
if(_E,_C1,_C2),_sig -> if(_EP, _C1, _C2), _sigP

-while
---
while(_E, _C),_sig -> if(_E, seq(_C, while(_E,_C)), __done), _sig

-variable
---
deref(_R), _sig -> __get(_sig, _R), _sig

-play
_phrase |> __string(_)
---
play(_phrase), _sig -> __user(1, _phrase), _sig

-playResolve
_phrase, _sig -> _phraseP, _sigP
---
play(_phrase), _sig -> play(_phraseP), _sigP

-setBpm
_n |> __int32(_)
---
setBpm(_n), _sig -> __user(0, _n), _sig

-setBpmResolve
_E1 -> _I1
---
setBpm(_E1), _sig -> setBpm(_I1), _sig

-concat
_phrase1 |> __string(_) _phrase2 |> __string(_)
---
concat(_phrase1, _phrase2), _sig -> __user(3, _phrase1, _phrase2), _sig

-concatRight
_phrase1 |> __string(_) _phrase2, _sig -> _phrase2P, _sigP
---
concat(_phrase1, _phrase2), _sig -> concat(_phrase1, _phrase2P), _sigP

-concatLeft
_phrase1, _sig -> _phrase1P, _sigP
---
concat(_phrase1, _phrase2), _sig -> concat(_phrase1P, phrase2), _sigP


!trace 6
//!try seq(assign(a, 15), seq(seq(seq(assign(b, 9), while(ne(deref(a), deref(b)), if(gt(deref(a), deref(b)), assign(a, sub(deref(a), deref(b))), assign(b, sub(deref(b), deref(a)))))), assign(gcd, deref(a))), backend(1, 2, 3)))
// !try seq(seq(seq(seq(assign(a, 15), assign(b, 9)), while(ne(deref(a), deref(b)), if(gt(deref(a), deref(b)), assign(a, sub(deref(a), deref(b))), assign(b, sub(deref(b), deref(a)))))), assign(gcd, deref(a))), backend(1, 2, 3))
// !try seq(assign(cMajScale, "[C:4:8, D:4:8, E:4:8, F:4:8, G:4:8, A:4:8, B:4:8, C:5:8]"),assign(x, 5)), __map
// !try add(1, 2), __map
// !try sub(1, 2), __map
// !try mul(4, 5), __map
// !try div(4, 5), __map
// !try div(9, 5), __map
// !try eq(1, 1), __map
// !try ne(1, 1), __map
// !try gt(1, 1), __map
// !try ge(1, 1), __map
// !try lt(1, 1), __map
// !try le(1, 1), __map

// Test if-then-else
// !try if(gt(2,1), assign(x, "True"), assign(x, "False")), __map
// Test if-then with no else (just use __done)
// !try if(lt(2, 1), assign(x,"True"), __done), __map

//!try seq(
//  seq(
//    seq(
//      seq(assign(a, 15),
//          assign(b, 9)
//      ),
//      while(
//        ne(deref(a), deref(b)), 
//        if(
//          gt(deref(a), deref(b)),
//          assign(a, sub(deref(a), deref(b))),
//          assign(b, sub(deref(b), deref(a)))))
//      ),
//      assign(gcd, deref(a))),
//  __done), __map

// Test while with sub
// !try seq(
//   assign(a, 10),
//   while(
//     ne(deref(a), 11),
//     assign(a, add(deref(a), 1))
//   )
// ), __map

// Test while loop
// !try 
//   seq(
//     setBpm(120),
//     seq(
//       assign(
//         n, 0
//       ),
//       seq(
//         assignPhrase(
//           "x",
//           "[C3:8, C3:8, C4:8, C4:8, Eb4:8, Eb4:8, C4:8, C4:8, Ab2:8, Ab2:8, Ab3:8, C4:8, G2:8, G2:8, Bb3:8, C4:8]"
//         ),
//         while(
//           ne(deref(n), 4),
//           seq(
//             play("x"),
//             assign(n, add(deref(n), 1)
//         )
//       )
//     )
//   )
// )), __map

// test modulation
// !try
//   seq(
//     assign(
//       x,
//       "[C3:8, C3:8, C4:8, C4:8, Eb4:8, Eb4:8, C4:8, C4:8, Ab2:8, Ab2:8, Ab3:8, C4:8, G2:8, G2:8, Bb3:8, C4:8]"
//     ),
//     play(
//         modulate(
//           deref(x),
//           5
//         )
//       )
//     )
//   , __map

// Test modulation and assignment
//!try
//  seq(
//    setBpm(120),
//    seq(
//      assign(
//        x,
//        "[C3:8, C3:8, C4:8, C4:8, Eb4:8, Eb4:8, C4:8, C4:8, Ab2:8, Ab2:8, Ab3:8, C4:8, G2:8, G2:8, Bb3:8, C4:8]"
//      ),
//      seq(
//        assign(
//          y,
//          modulate(deref(x), 5)
//        ),
//        seq(
//          play(deref(x)), play(deref(y))
//        )
//      )  
//    )    
//  ), __map

// Test anonymous phrases modulated from a named phrase
//!try
//  seq(
//    setBpm(120),
//    seq(
//      assign(
//        x,
//        "[C3:8, C3:8, C4:8, C4:8, Eb4:8, Eb4:8, C4:8, C4:8, Ab2:8, Ab2:8, Ab3:8, C4:8, G2:8, G2:8, Bb3:8, C4:8]"
//      ),
//      seq(
//        assign(
//          n, 0
//        ),
//        while(
//            ne(deref(n), 4),
//            seq(
//              play(
//                modulate(deref(x), deref(n))
//              ),
//              assign(n, add(deref(n), 1))
//          )
//        )
//      )
//    )
//  ), __map

// Concatenate two phrases, assign to x, and play them.
!try seq(
  setBpm(120),
  seq(
    assign(
       x, 
       concat(
        "[C3:8, C3:8, C4:8, C4:8, Eb4:8, Eb4:8, C4:8, C4:8]",
        "[Ab2:8, Ab2:8, Ab3:8, C4:8, G2:8, G2:8, Bb3:8, C4:8]"
      )
    ),
    play(deref(x)
  )
)), __map