(* relation '->' *)
(* constructor if *)
-ifTrue  --- if(True, _C1, _C2), _sig -> _C1, _sig
-ifFalse  --- if(False, _C1, _C2), _sig -> _C2, _sig
-ifResolve _E, _sig -> _EP, _sigP --- if(_E, _C1, _C2), _sig -> if(_EP, _C1, _C2), _sigP
(* constructor assign *)
-assignStr _str |> _ --- assign(_ID, _str), _sig -> __done, __put(_sig, _ID, _str)
-assignInt _n |> _ --- assign(_X, _n), _sig -> __done, __put(_sig, _X, _n)
-assignIntResolve _E, _sig -> _I, _sigP --- assign(_X, _E), _sig -> assign(_X, _I), _sigP
-assignStrResolve _str, _sig -> _strP, _sigP --- assign(_ID, _str), _sig -> assign(_ID, _strP), _sigP
(* constructor sub *)
-sub _n1 |> _  _n2 |> _ --- sub(_n1, _n2), _sig -> __sub(_n1, _n2), _sig
-subRight _n |> _  _E2, _sig -> _I2, _sigP --- sub(_n, _E2), _sig -> sub(_n, _I2), _sigP
-subLeft _E1, _sig -> _I1, _sigP --- sub(_E1, _E2), _sig -> sub(_I1, _E2), _sigP
(* constructor while *)
-while  --- while(_E, _C), _sig -> if(_E, seq(_C, while(_E, _C)), __done), _sig
(* constructor mul *)
-mul _n1 |> _  _n2 |> _ --- mul(_n1, _n2), _sig -> __mul(_n1, _n2), _sig
-mulRight _n |> _  _E2, _sig -> _I2, _sigP --- mul(_n, _E2), _sig -> mul(_n, _I2), _sigP
-mulLeft _E1, _sig -> _I1, _sigP --- mul(_E1, _E2), _sig -> mul(_I1, _E2), _sigP
(* constructor deref *)
-variable  --- deref(_R), _sig -> __get(_sig, _R), _sig
(* constructor div *)
-div _n1 |> _  _n2 |> _ --- div(_n1, _n2), _sig -> __div(_n1, _n2), _sig
-divRight _n |> _  _E2, _sig -> _I2, _sigP --- div(_n, _E2), _sig -> div(_n, _I2), _sigP
-divLeft _E1, _sig -> _I1, _sigP --- div(_E1, _E2), _sig -> div(_I1, _E2), _sigP
(* constructor play *)
-play _phrase |> _ --- play(_phrase), _sig -> __user(1, _phrase), _sig
-playResolve _phrase, _sig -> _phraseP, _sigP --- play(_phrase), _sig -> play(_phraseP), _sigP
(* constructor gt *)
-gt _n1 |> _  _n2 |> _ --- gt(_n1, _n2), _sig -> __gt(_n1, _n2), _sig
-gtRight _n |> _  _E2, _sig -> _I2, _sigP --- gt(_n, _E2), _sig -> gt(_n, _I2), _sigP
-gtLeft _E1, _sig -> _I1, _sigP --- gt(_E1, _E2), _sig -> gt(_I1, _E2), _sigP
(* constructor setBpm *)
-setBpm _n |> _ --- setBpm(_n), _sig -> __user(0, _n), _sig
-setBpmResolve _E1 -> _I1 --- setBpm(_E1), _sig -> setBpm(_I1), _sig
(* constructor modulate *)
-modulate _phrase |> _  _n |> _ --- modulate(_phrase, _n), _sig -> __user(2, _phrase, _n), _sig
-modulateResolveRight _phrase |> _  _E1, _sig -> _I1, _sigP --- modulate(_phrase, _E1), _sig -> modulate(_phrase, _I1), _sigP
-modulateResolveLeft _phrase, _sig -> _phraseP, _sigP --- modulate(_phrase, _E1), _sig -> modulate(_phraseP, _E1), _sigP
(* constructor ge *)
-ge _n1 |> _  _n2 |> _ --- ge(_n1, _n2), _sig -> __ge(_n1, _n2), _sig
-geRight _n |> _  _E2, _sig -> _I2, _sigP --- ge(_n, _E2), _sig -> ge(_n, _I2), _sigP
-geLeft _E1, _sig -> _I1, _sigP --- ge(_E1, _E2), _sig -> ge(_I1, _E2), _sigP
(* constructor concat *)
-concat _phrase1 |> _  _phrase2 |> _ --- concat(_phrase1, _phrase2), _sig -> __user(3, _phrase1, _phrase2), _sig
-concatRight _phrase1 |> _  _phrase2, _sig -> _phrase2P, _sigP --- concat(_phrase1, _phrase2), _sig -> concat(_phrase1, _phrase2P), _sigP
-concatLeft _phrase1, _sig -> _phrase1P, _sigP --- concat(_phrase1, _phrase2), _sig -> concat(_phrase1P, phrase2), _sigP
(* constructor lt *)
-lt _n1 |> _  _n2 |> _ --- lt(_n1, _n2), _sig -> __lt(_n1, _n2), _sig
-ltRight _n |> _  _E2, _sig -> _I2, _sigP --- lt(_n, _E2), _sig -> lt(_n, _I2), _sigP
-ltLeft _E1, _sig -> _I1, _sigP --- lt(_E1, _E2), _sig -> lt(_I1, _E2), _sigP
(* constructor le *)
-le _n1 |> _  _n2 |> _ --- le(_n1, _n2), _sig -> __le(_n1, _n2), _sig
-leRight _n |> _  _E2, _sig -> _I2, _sigP --- le(_n, _E2), _sig -> le(_n, _I2), _sigP
-leLeft _E1, _sig -> _I1, _sigP --- le(_E1, _E2), _sig -> le(_I1, _E2), _sigP
(* constructor seq *)
-sequenceDone  --- seq(__done, _C), _sig -> _C, _sig
-sequence _C1, _sig -> _C1P, _sigP --- seq(_C1, _C2), _sig -> seq(_C1P, _C2), _sigP
(* constructor ne *)
-ne _n1 |> _  _n2 |> _ --- ne(_n1, _n2), _sig -> __ne(_n1, _n2), _sig
-neRight _n |> _  _E2, _sig -> _I2, _sigP --- ne(_n, _E2), _sig -> ne(_n, _I2), _sigP
-neLeft _E1, _sig -> _I1, _sigP --- ne(_E1, _E2), _sig -> ne(_I1, _E2), _sigP
(* constructor eq *)
-eq _n1 |> _  _n2 |> _ --- eq(_n1, _n2), _sig -> __eq(_n1, _n2), _sig
-eqRight _n |> _  _E2, _sig -> _I2, _sigP --- eq(_n, _E2), _sig -> eq(_n, _I2), _sigP
-eqLeft _E1, _sig -> _I1, _sigP --- eq(_E1, _E2), _sig -> eq(_I1, _E2), _sigP
(* constructor add *)
-add _n1 |> _  _n2 |> _ --- add(_n1, _n2), _sig -> __add(_n1, _n2), _sig
-addRight _n |> _  _E2, _sig -> _I2, _sigP --- add(_n, _E2), _sig -> add(_n, _I2), _sigP
-addLeft _E1, _sig -> _I1, _sigP --- add(_E1, _E2), _sig -> add(_I1, _E2), _sigP

(*-----------------------*)

